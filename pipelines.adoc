## Lab: Automating Deployment with CI/CD Pipeline

### Background: CI/CD Pipeline

継続的インテグレーションと継続的デリバリーは、ソフトウェアデリバリの様々な側面で自動化とともげ給される。
これらの練習の1つは、コードまたは構成の変更がステージングやプロダクションなどの上位環境に到達するために通過する必要がある手順を定義する自動化されたプロセスであるパイプラインです。
OpenShift は、人気のある https://jenkins.io/doc/book/pipeline/overview/[Jenkins pipelines] をプラットフォームに統合して CI/CD パイプラインをサポートし、OpenShift 内で直接複雑なワークフローを定義することができます。


前の実習（または、演習の事前準備）では、 https://{{DOCS_URL}}/latest/architecture/core_concepts/builds_and_image_streams.html#source-build[Source-to-Image (S2I)] を使用して `nationalparks` アプリケーションを配備しました。
S2I は、ソースコードが変更されたとき、または基になるイメージの変更時にビルドを自動的に実行することで、ビルド自動化を提供します
デプロイメントは S2I によって自動化され、イメージの変更に基づいてトリガされます。
この実習では、ビルドおよびデプロイプロセスにさらにステップを追加することにより、S2I 機能を拡張するパイプラインを作成することにより、より複雑なワークフローを作成します。
次の図は、この演習で作成するパイプラインを示しています。


image::pipeline-diagram.png[CI/CD Pipeline Diagram,800,align="center"]


このパイプラインでは、`nationalparks` アプリケーションには2つの環境があります。
*Dev* コンテナは、開発とテスト用に、全ての変更が反映され、それに対して自動化されたテストを実行できる。
さらに、テストチームはこのコンテナーで手動テストを実行し、テストケースを通じて検出されたバグを報告できます。
テストがすべて成功し、チーム内の _Deployment Manager_ が変更を承認すると、SLA が定義された運用環境である *Live* コンテナに展開され、常時正常に機能することが重要になります。


パイプラインの実行は、アプリケーションコードまたは構成の変更を行う開発者から始まります。
すべての変更について、次の手順は、変更が *Live* 環境での展開に適しているかどうかを判断する目的で実行されます。


. Git リポジトリからソースコードをクローン
. ソースコードをビルドし単体テストを実行
. アプリケーション組み込み済みのDockerイメージを作成(S2I)
. *Dev* プロジェクトへDockerイメージのデプロイ
. *Dev* プロジェクトに対して自動テストを実行
. *Dev* プロジェクトにデプロイされたアプリケーションで手動テストを実行
. *Devployment Manager* の判断（承認 or 拒否）待ち（例. テスト結果に受け入れ不可な数のBugがあったなど）
. 承認されたら *Live* プロジェクトへデプロイ


`Jenkins` を展開し、OpenShift 上でこのパイプラインを作成するに移動してみましょう。


### Exercise: Deploy Jenkins

OpenShift は、完全なパイプラインの流れを可能にするプラグインの豊富なセットが含まれていますサポートされているJenkinsのイメージを提供します。*Add to project* ボタンをクリックします。次に、*Technologies* セクションまでスクロールし、*Continuous Integration & Deployment* をクリックします。


image::pipeline-technologies.png[CI/CD Technologies]


`jenkins-ephemeral` テンプレートを見つけ、それをクリックしてください:


image::pipeline-jenkins-catalog.png[Jenkins Ephemeral]


サービス名、管理者パスワード、メモリ割り当てなど、web コンソールのパラメータを使用して、Jenkinsのプロパティをカスタマイズすることができます。我々は、すべてのデフォルト値のままにすることができますので、*Create* をクリックして　Jenkinsを展開します。 OpenShift は、Jenkins Pod を配備し、また、配備されたコンテナのサービスとルートを作成します。


image::pipeline-jenkins-pods.png[Jenkins Pods]


Jenkinsのルートをクリックしてコンソールを開きます。再度証明書を受け入れる必要があります。Red Hat によって提供されるJenkinsのイメージは、OpenShift との OAuth の統合を使用します。OpenShift ユーザーの資格情報は、Jenkinsの管理者の資格情報にもなります:


image::pipeline-jenkins-credentials.png[Login with OpenShift]


*Login with OpenShift* をクリックすると、OpenShiftのログイン画面にリダイレクトされます。ユーザー名 (_{{USER_NAME}}_) とパスワード (_{{USER_PASSWORD}}_) を使用して、Jenkinsにアクセスします。次に、アクセスを許可するかどうかを確認するメッセージが表示されます。


image::pipeline-jenkins-permissions.png[Grant Jenkins Permissions]


*Allow selected permissions* をクリックします。


image::pipeline-jenkins-console.png[Jenkins Console]


OpenShift Jenkinsプラグインは、さまざまな OpenShift 操作に統合するために OpenShift REST API を使用しています。我々はJenkinsさんが私たちのプロジェクトを見て色々なことを行うことができるようにしたいので、我々は追加のアクセス許可を付与する必要があります。Jenkinsサービスアカウントは、テンプレートを介してJenkinsを展開するときに自動的に作成されました。次の CLI コマンドを実行して、Jenkinsサービスアカウントが情報を取得し、OpenShift でアクションを起動できるようにします。


[source]
----
$ oc policy add-role-to-user edit -z jenkins
----

### Exercise: Remove Dev from `parksmap`

我々は *Live* のバージョンでは、現在の `nationalparks` アプリケーションを置き換えることになるので、我々は *Route* ラベルを削除することによって、`parksmap` から *Dev* バージョンを削除する必要があります:


[source]
----
$ oc get route
$ oc describe route nationalparks-dev
$ oc label route nationalparks-dev type-
----

### Exercise: Create Live Environment

パイプラインを作成する前に、live バージョンの `nationalparks` アプリケーションを実行する *Live* デプロイメントを作成する必要があります。`parksmap` フロントエンドは、*Live* `nationalparks` と連携します。これにより、開発者は、ライブアプリケーションに干渉することなく、*Dev* デプロイメントに頻繁に変更を加えることができます。


#### Live MongoDB

まず、*Live* 環境用の新しい MongoDB 展開を作成する必要があります。web コンソールの `{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}` プロジェクトで、*Add to Project* ボタンをクリックし、プルダウンメニューから *Browse Catalog* を選択します。*Databases* タブから `mongodb-ephemeral` テンプレートを見つけてクリックします。 それぞれのフィールドで次の値を使用します。

image::pipeline-mongodblive-addtoproject.png[Add to Project]
image::pipeline-mongodblive-catalog.png[Catalog]


ウィザード画面  Configuration 
以下の値を入力する。

|===
| パラメータ名|環境変数名|値
|Add to Project||explore-XX
|Database Service Name||`mongodb-live`
|MongoDB Connection Username|`MONGODB_USER`|`mongodb`
|MongoDB Connection Password| `MONGODB_PASSWORD`|`mongodb`
|MongoDB Database Name| `MONGODB_DATABASE`|`mongodb`
|MongoDB Admin Password| `MONGODB_ADMIN_PASSWORD`|`mongodb`
|===

ウィザード画面 Bindings
*Do not bind at this time* を選択する。


残りの値はデフォルトとして残すことができ、*Create* をクリックします。次に *Containue* をクリックして概要に進みます。MongoDB インスタンスはすぐに配備される必要があります。あなたが興味を持っている場合は、それが起動したときに何をするかを確認するために Mongo のログを見てみましょう。


{% if modules.configmap %}


#### Live ConfigMap

*Dev* `nationalparks` web ページのデータベース構成は、 *ConfigMaps* を使用するして接続情報のプロパティを設定します。同様に、我々は `nationalpark-live` のための *ConfigMap* を使用します。ライブプロパティファイルをローカルマシンにダウンロードし、別個の *ConfigMap* を作成します。このファイルは次の場所にあります。


[source,role=copypaste]
----
http://gitlab-ce-workshop-infra.{{ROUTER_ADDRESS}}/{{GITLAB_USER}}/nationalparks/raw/{{NATIONALPARKS_VERSION}}/ose3/application-live.properties
----


次のコマンドを実行して、live *ConfigMap* を作成します。


[source]
----
$ oc create configmap nationalparks-live --from-file=application.properties=./application-live.properties
----
{% endif %}

#### Live Deployment


image:: pipeline-imagestream.png 
イメージストリームは、OpenShift 内/外にある Docker Image へのポインタです。


`nationalparks` Docker イメージを利用して、*Live* デプロイメントを作成できます。画面左側のメユーで *Build* &rarr; *Images* を選択し `nationalparks` *ImageStream* を確認します。


image::pipeline-live-image.png[National Parks Image Stream]


OpenShift https://{{DOCS_URL}}/latest/architecture/core_concepts/builds_and_image_streams.html[S2I build] では、内部レジストリにプッシュされる新しい Docker イメージを作成し、`latest` のタグで識別します。イメージが変更されたときに `nationalparks` の *Live* バージョンをすぐに実行したり展開したりしたくないので、*Dev* および *Live* デプロイメントでは、 `nationalparks` イメージの異なるバージョンを同時に実行するための機能が必要になります。これにより、開発者は *Live* 環境に影響を与えることなく、 *Dev* の変更と展開を継続できます。そのためには、CLI を使用して新しい Docker イメージタグを作成します。 この新しいタグは、*Live* の展開が変更を検索するものになります:


[source]
----
$ oc tag nationalparks:latest nationalparks:live
----


あなたは、UI で *ImageStream* 一覧の表示が変わったことが確認できます。


このコマンドは「既存のタグ `nationalparks:latest` を指し示すイメージと同じイメージを `nationalparks:live` で指し示してください。」または、「 `latest` と同じイメージを指し示す新しいタグ( `live` )を作ってください。」という意味です。


_新しい_ ビルドは `latest` タグを更新しますが、 `live` タグの更新は、手動コマンドのみです (または自動化されたワークフロー, 我々はJenkinsで実装します)。 `live` タグは性 Docker イメージを参照し続けているため、*Live* 環境はそのまま残されます。


タグを作成した後、`nationalparks:live` イメージタグに基づいて、*Live* `nationalparks` を展開する準備が整いました。web コンソールの `{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}` プロジェクトで、*Add to Project* プルダウンメニューから、*Deploy Image* を選択します。
*Image Stream Tag* ラジオボタンを選び、それぞれのフィールドで次の値を使用します。


|===
|Namespace:| `{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}`
|ImageStream:| `nationalparks`
|Tag:| `live`
|Name:| `nationalparks-live`
|===

image::pipeline-nationalparkslive-deploy.png[Nationalparks-Live Deploy]


*Image Stream Tag* 領域で3つのドロップダウンを選択すると、標準の展開オプション "open up"の残りの部分が表示されます。


[WARNING]
====
名前を`nationalparks-live`に変更することを忘れた場合は、既に存在するリソースに関するエラーが表示されます。`nationalparks` は、*Dev* デプロイメントとして既に存在します。
====


{% if modules.configmap %}


image::pipeline-live-deploy-config.png[National Parks Live Deploy]


{% else %}


次の環境変数を指定して、*Live* コンテナを *Live* データベースに接続します。


* `MONGODB_SERVER_HOST`: `mongodb-live`
* `MONGODB_USER`: `mongodb`
* `MONGODB_PASSWORD`: `mongodb`
* `MONGODB_DATABASE`: `mongodb`


CLI で実行する場合
```
oc env dc nationalparks-live -e MONGODB_SERVER_HOST=mongodb-live -e MONGODB_USER=mongodb -e MONGODB_PASSWORD=mongodb -e MONGODB_DATABASE=mongodb
```

UIで実施する場合は、nationalparks の Deployment Config の詳細画面で *Environment* タブを選択します。


image::pipeline-live-deploy-env.png[National Parks Live Deploy]


{% endif %}

残りの値はデフォルトとして残すことができ、*Create* をクリックします。次に、 *Containuer to overview* をクリックして進みます。


{% if modules.configmap %}


#### Attach ConfigMap

UI を通して `nationalparks-live` イメージを配備することは、*ConfigMap* を利用しませんでした。それで、私たちは、1つのより多くのステップを持っています--プロパティ・ファイルを置く場所を OpenShift に伝えるために。あなたはすでに *ConfigMap* を作成しているので、あなたがしなければならないすべては、適切な場所にそれを置くために `oc set volume` コマンドを使用しています:


[source]
----
$ oc set volumes dc/nationalparks-live --add -m /deployments/config --configmap-name=nationalparks-live
----


{% endif %}

#### Add Route

web コンソールを見ると、この方法でアプリケーションを作成すると、OpenShift では *Route* が作成されないことがわかります。*NATIONALPARKS LIVE* の右下隅にある *Create Route* をクリックし、*Create* を使用してデフォルト値のルートを作成します。
image::pipeline-nationalparkslive-route.png[Nationalparks Live Route]

`nationalparks-live` の url にブラウザでアクセスして、接続の確認とデータのロードをおこないます。


[source]
----
http://nationalparks-live-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}/ws/data/al/
http://nationalparks-live-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}/ws/data/loa/
----


[NOTE]
====
アプリケーションがまだデプロイされていない場合は、__502 の不正なゲートウェイエラー webpage__ が発生することがあります。これは、ルートをバックアップするアプリケーションがまだ準備できていないことを意味します。Podが起動するまで待ちます。
====


#### Label Service

`parksmap` web アプリケーションは OpenShift API を照会し、ラベル `type=parksmap-backend` を持つルートを検索し、検出されたエンドポイントを問い合わせしてマップデータを視覚化します。パイプラインを作成した後、`parksmap` は *Dev* コンテナの代わりに *Live* コンテナを使用して、*Dev* コンテナへのデプロイメントが `parksmap` アプリケーションを中断しないようにする必要があります。 あなたは、*Dev* ルートから `type` ラベルを削除し、*Live* ルートに追加することによってそれを行うことができます:


[source]
----
$ oc label route nationalparks-live type=parksmap-backend
----


{% if DISABLE_NATIONALPARKS_DEPLOYMENT_PIPELINE %}
### Exercise: Disable Automatic Deployment of nationalparks (dev)

ワークショップで以前に `nationalparks` ビルドを作成したときに、OpenShift が `:latest` タグが更新されるたびに自動的に発生するようにイメージの展開を構成しました。


私たちのパイプラインの例では、Jenkinsは、それが正常にビルドされた場合、`nationalparks` の dev のバージョンを展開する OpenShift 指示を処理するつもりです。2つの展開を防ぐために、単純な CLI ステートメントを使用して自動デプロイメントを無効にする必要があります。


[source]
----
$ oc set triggers dc/nationalparks --from-image=nationalparks:latest --remove
----


{% endif %}

### Exercise: Create OpenShift Pipeline

パイプラインは実際には開発者がJenkinsパイプラインプラグインによって実行のためのJenkinsパイプラインを定義することで可能となるビルドのタイプです。ビルドは、他のビルドの種類と同じ方法で、{{OPENSHIFT_NAME}} によって開始、監視、および管理できます。パイプラインワークフローは、ビルド構成に直接埋め込まれるか、または Git リポジトリで提供され、ビルド構成によって参照される Jenkinsfile で定義されます。


パイプラインを作成するには、*Add to project* ボタンをクリックし、`dev-live-pipeline` テンプレートを見つけてクリックします。プロジェクト名を指定し、*Create* をクリックします。


[NOTE]
====
`nationalparks` *Dev* と *Live* コンテナがデプロイされる プロジェクト名を記述します（例 `{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}`)
====


image::pipeline-template.png[Pipeline Template]


前の手順で作成したパイプラインを開始するには、左側のバーにある *Builds* &rarr; *Pipeline* に移動します。`nationalparks-pipeline` をクリックし、*Start Build* をクリックして実行を開始します。 *View Log* をクリックすると、パイプラインまたは *Build #N* で進行中のビルドログを見て、この特定のパイプライン実行の詳細と https://jenkins.io/doc/book/pipeline/overview/[JEnkins DSL] を使用したパイプライン定義を確認できます。


image::pipeline-details.png[Pipeline Details]


パイプラインの定義方法によって、概要ページに戻ると、関連する展開に関連付けられたパイプラインの状態も表示されます。

image::pipeline-deploy-dev.png[Pipeline - Deploy to Dev]


パイプラインの実行は、*Dev* コンテナに対して自動テストを実行した後、一時停止します。データを照会し、サービスが期待どおりに動作することを確認するには、`nationalparks` *Dev* web サービスを参照してください。


[source]
----
http://nationalparks-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}/ws/data/all/
----


[NOTE]
====
アプリケーションがまだ展開されていない場合は、__502 の不正なゲートウェイエラー webpage__ が発生する可能性があります。これは、ルートをバックアップするアプリケーションがまだ準備できていないことを意味します。Podが起動されるまで待ちます。
====


テスト段階の後、パイプラインは、*Live* コンテナに展開するために手動承認を待機します。


image::pipeline-input.png[Manual Approval]


*Input Required* リンクをクリックして、承認するためのJenkinsコンソールを開きます。この手順は通常、ワークフロープロセス (JIRA サービスデスクや ServiceNow など) に統合され、Jenkinsさんと直接やり取りすることなく、全体的な展開プロセスの一環として実行されます。この演習で簡単にするために、*Proceed* ボタンをクリックしてビルドを承認します。


image::pipeline-jenkins-input.png[Jenkins Approval,1000,align=center]


パイプラインの実行は、`nationalparks` イメージのプロモートとデプロイを継続します。 これは、作成されたイメージに、テスト済みを示す "live" タグをつける。 タグ付けによって `imagechange` トリガーが発生し *Live* にデプロイされる。


*Builds* &rarr; *Pipelines* で, *View History* をクリックしてください。 パイプラインの実行履歴を表示し、ビルドの時間のメトリックを繰り返してビルドプロセスを改善することができますので、パイプラインの概要に移動するだけでなく、通常、ビルド時の異常を検出するコードまたは構成の不正な変更を通知します。


[NOTE]
====
ビルドメトリックは、傾向を決定するためにパイプラインのいくつかの実行後に生成および表示されます。
====

image::pipeline-history.png[OpenShift History]


おめでとう!今、あなたは、`nationalparks` アプリケーションのための CI/CD パイプラインを持っています。再度公園の地図を訪問すれば、地図ポイントを見るべきである!
