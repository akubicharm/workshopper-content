## Lab: Creating Routes by Exposing Services

### Application description
In this lab, we're going to make our application visible to the end users, so they can access it.

この演習では、それにアクセスできるようにアプリケーションをエンド ・ ユーザーに表示されるようにするつもり。

image::roadshow-app-architecture-parksmap-2.png[Application architecture,800,align="center"]

### Background: Routes

While *Services* provide internal abstraction and load balancing within an OpenShift environment, sometimes clients (users, systems, devices, etc.) **outside** of OpenShift need to access an application. The way that external clients are able to access applications running in OpenShift is through the OpenShift routing layer. And the data object behind that is a *Route*.

OpenShift環境では*Servics* が内部抽象化と負荷分散を実現するので、OpenShiftの外部のクライアント (ユーザー、システム、装置、等) がアプリケーションにアクセスする必要があります。外部クライアントは、OpenShift で実行されているアプリケーションにアクセスする方法は、OpenShift ルーティング層を介してです。具体的には *Route* です。

The default OpenShift router (HAProxy) uses the HTTP header of the incoming request to determine where to proxy the connection. You can optionally define security, such as TLS, for the *Route*. If you want your *Services*, and, by extension, your *Pods*,  to be accessible to the outside world, you need to create a *Route*.


既定の OpenShift ルーター (HAProxy) は、着信要求の http ヘッダーを使用して、接続のプロキシ先を決定します。必要に応じて、TLS などのセキュリティを *Route* に定義できます。あなたの *Service*、および、拡張機能によって、あなたの *Pod* は、外部の世界にアクセスできるようにする場合は、*Route* を作成する必要があります。


#### Exercise: Creating a Route

Fortunately, creating a *Route* is a pretty straight-forward process.  You simply `expose` the *Service* via the command line. Or, via the web console, just click the "Create Route" button associated with the service.

幸いにも、*Route* の作成はかなりまっすぐ進むプロセスです。 あなたは単にコマンドラインで`expose` *Service* とするだけ。または、web コンソール経由でサービスに関連付けられている「ルートの作成」ボタンをクリックしますします。

First we want to verify that we don't already have any existing routes:

まず、既存のルートがないことを確認します。

[source]
----
$ oc get routes
No resources found.
----

Now we need to get the *Service* name to expose:

公開する *Service* の名前を取得する必要があります。

[source]
----
$ oc get services

NAME       CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
parksmap   172.30.169.213   <none>        8080/TCP   5h
----

Once we know the *Service* name, creating a *Route* is a simple one-command task:

*Services* 名がわかってしまえば、*Route* の作成は単純な 1 つのコマンド タスク。

[source]
----
$ oc expose service parksmap
route "parksmap" exposed
----

Verify the *Route* was created with the following command:

確認、*Route* は次のコマンドで作成されました。

[source]
----
$ oc get route
NAME       HOST/PORT                                              PATH      SERVICES   PORT       TERMINATION
parksmap   parksmap-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}             parksmap   8080-tcp
----

You can also verify the *Route* by looking at the project in the OpenShift web console:

OpenShift web コンソールでプロジェクトを見ることによって *Route* を確認することができます。

image::parksmap-route.png[Route]

Pretty nifty, huh?  This application is now available at the URL shown in the web console. Click the link and you will see:

かなり気が効いてるでしょ? このアプリケーションは、web コンソールに表示される URL で利用できるようになりました。リンクをクリックすると表示されます:

image::parksmap-empty.png[Route]
