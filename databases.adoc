## Lab: Adding a Database

### Application Description
// [silver]#In this lab, we're going to deploy a Mongo database that will be used to store the data for the `nationalparks` application. We will also connect the `nationalparks` service with the newly deployed Mongo database, so that the `nationalparks` service can load and query the database for the corresponding information.#

この演習では `nationalparks` アプリケーションのデータを格納するために使用する Mongo DB を配置していきます。
また、 `nationalparks` アプリケーションと Mongo DB を連携し、`nationalparks` サービスで利用するデータをロード、参照できるようにします。

// [silver]#Finally, we will mark the `nationalparks` application as a backend for the map visualization tool, so that it can be dynamically discovered by the `parksmap` component using the OpenShift discovery mechanism and the map will be displayed automatically.#

最後に、 `nationalparks` アプリケーションを地図表示アプリケーションのバックエンドサービスとして `parksmap` アプリケーションと連携させます。

image::roadshow-app-architecture-nationalparks-2.png[Application architecture,800,align="center"]

### Background: Storage

// [silver]#Most useful applications are "stateful" or "dynamic" in some way, and this is usually achieved with a database or other data storage. In this next lab we are going to add MongoDB to our `nationalparks` application and then rewire it to talk to the database using environment variables.#

有用なアプリケーションは、何らかの方法で "ステートフル" や "動的" な作りになっており、これらを実現するためにデータベースやデータストレージが使われます。このラボでは MongoDB と `nationalparks` アプリケーションを連携させるために、接続情報を環境変数で設定します。

// [silver]#We are going to use the MongoDB image that is included with OpenShift.#

OpenShift に含まれている MongoDB イメージを使用しています。

// [silver]#By default, this will use *EmptyDir* for data storage, which means if the *Pod* disappears the data does as well. In a real application you would use OpenShift's persistent storage mechanism to attach real-world storage (NFS, Gluster, EBS, etc) to the *Pods* to give them a persistent place to store their data.#

デフォルトでは、これはデータストレージに *EmptyDir* を使用しますが、これは *Pod* がデータを消失するかどうかを意味します。実際のアプリケーションでは、OpenShift の永続ストレージメカニズムを使用して、実際のストレージ (NFS、Gluster、EBS など) を *Pods* に接続し、データを保存するための永続的な場所を提供します。

### Background: Environment Variables

// [silver]#As you've seen so far, the web console makes it very easy to deploy things onto OpenShift. When we deploy the database, we pass in some environment variables.  These environment variables are used to set the username, password, and name of the database.  You can change the values of these environment variables to anything you would like.  The variables we are going to be setting are as follows:#

これまで見てきたように、Web コンソールを利用すると、OpenShift にアプリケーションをデプロイすることが非常に簡単です。データベスをデプロイする場合には、いくつかの環境変数を設定さえすれば良いです。環境変数にはユーザ名、パスワードとデータベース名を設定します。
設定している変数は次のとおりです。

- MONGODB_USER
- MONGODB_PASSWORD
- MONGODB_DATABASE
- MONGODB_ADMIN_PASSWORD

// [silver]#The database image is built in a way that it will automatically configure itself using the supplied information (assuming there is no data already present in the persistent storage!). The image will ensure that:#

// - A database exists with the specified name
// - A user exists with the specified name
// - The user can access the specified database with the specified password

データベースのイメージは、自動的に (永続的なストレージに存在するデータがないと仮定!) 指定された情報を使用して自分自身を設定するという方法で構築されます。イメージを確認します。

- 指定した名前のデータベースが存在する
- 指定した名前のユーザーが存在する
- 指定されたパスワードで指定されたデータベースにアクセスできる

// [silver]#In the web console in your `{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}` project, again click the *"Add to Project"* button. Click the *Data Stores* category.#

Web コンソールの `{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}` プロジェクトで、もう一度クリックして、*Add to Project* ボタン。クリックして、*Data Stores* カテゴリを選択します。

image::mongodb-datastores.png[Data Stores]

// [silver]#Type `mongodb` in the search box, and then scroll down to find the *MongoDB (Ephemeral)* template, and click it.  You will notice that there are several MongoDB templates available, some of which come with application servers pre-configured.  We just need a database, though, so the ephemeral Mongo template is what you should choose.#

検索ボックスに `mongodb` と入力し、下にスクロールして *MongoDB (Ephemeral)* テンプレートを見つけてクリックします。 使用可能な MongoDB テンプレートがいくつかあり、そのうちのいくつかがアプリケーションサーバーにあらかじめ構成されていることがわかります。 私たちは、しかし、データベースを必要とするので MongoDB(Ephemeral) テンプレートを選択する必要があります。

image::ocp-mongodb-template.png[MongoDB]

// [silver]#When we performed the application build, there was no template. Rather, we selected the builder image directly and OpenShift presented only the standard build workflow.  Now we are using a template - a preconfigured set of resources that includes parameters that can be customized. In our case, the parameters we are concerned with are the environment variables discussed -- user, password, database, and admin password.#

S2I ビルドの方式でアプリケーションをビルドする場合には、カタログとして表示されているビルダーイメージを選択しました。
このラボでは、テンプレートを利用して、あらかじめ定義されたパラメータの値を設定することでカスタマイズを行っています。
今回のケースでは、パラメータでカスタマイズしている項目は、ユーザ、パスワード、データベース名と管理者パスワードです。

image::ocp-mongo-template-deploy.png[MongoDB]

// [silver]#You can see that some of the fields say *"generated if empty"*. This is a feature of *Templates* in OpenShift that will be covered in the next lab. For now, be sure to use the following values in their respective fields:#

パラメータのフィールドの一部には、*generated if empty* と表示されています。これは、明示的に指定しない場合はルールに従って値を生成することを意味しています。


|===
| パラメータ名|環境変数名|値
|MongoDB Connection Username|`MONGODB_USER`|`mongodb`
|MongoDB Connection Password| `MONGODB_PASSWORD`|`mongodb`
|MongoDB Database Name| `MONGODB_DATABASE`|`mongodb`
|MongoDB Admin Password| `MONGODB_ADMIN_PASSWORD`|`mongodb`
|===

// [silver]#You can leave the rest of the values as their defaults, and then click *"Create"*. Then click *Continue to overview*. The MongoDB instance should quickly be deployed.#

上記の値のみを指定し、それ以外はデフォルトのままで *Create* をクリックし、*Continue to view* をクリックいます。
Mongo DB のインスタンスは、既存のコンテナイメージを利用するのですぐにデプロイが終わります。

image::mongo-group-db-1.png[Service Groups]


// [silver]#You can group services in OpenShift Console in order to display related services together in one panel. Click on the chain icon on the right-top corner of the `nationalparks` service, choose `mongodb` from the drop-down list in the *Group Service to nationalparks* dialog and click on *OK*. The `nationalparks` and `mongodb` services are groups and displayed together.#


#### Exercise: Wiring the Application and the Database

// [silver]#When we initially created the `nationalparks` application, we provided no environment variables. The application is looking for a database, but can't find one, and it fails gracefully (you don't see an error).#

最初に `nationalparks` アプリケーションを作成したとき、我々は環境変数を提供しませんでした。アプリケーションはデータベースを探していますが、1つを見つけることができず、正常に失敗します (エラーが表示されません)。

// [silver]#We need to configure the `nationalparks` *Pod*(s) to have the right values in the right environment variables so that the application knows how and where to find MongoDB.#

`nationalparks` *Pod*(s)に環境変数を設定する必要があります。環境変数でデータベースの接続上情報を設定することで、`nationalparks` アプリケーションがデータベースに接続できるようになります。

// [silver]#If you think way back to the beginning of the labs, you will recall that a *DeploymentConfiguration* tells OpenShift how to deploy something. This includes things like what environment variables to configure. So, to set up the right environment variables, we simply need to modify the *DeploymentConfiguration* (DC).  This can easily be done from either the web interface or via the command line.#


ラボの最初を振り返ると、*DeploymentConfiguration* は何かを展開する方法を OpenShift に指示することを思い出してみてください。
*DeploymentConfiguration* には構成する環境変数のようなものが含まれます。したがって、適切な環境変数を設定するには、*DeploymentConfiguration* (DC) を変更する必要があります。 これは、web インターフェイスまたはコマンドラインを介してから行うことができます。

// [silver]#The command line takes a little less time, so let's use that option. First, find the name of the DC:#

コマンドラインを利用していきましょう。

まず、DeploymentConfig を確認します。

[source]
----
$ oc get dc
----

// [silver]#Then, use the `oc env` command to set environment variables directly on the DC:#

その後、DC に直接環境変数を設定する `oc env` コマンドを使用します。

[source]
----
$ oc env dc nationalparks -e MONGODB_USER=mongodb -e MONGODB_PASSWORD=mongodb -e MONGODB_DATABASE=mongodb -e MONGODB_SERVER_HOST=mongodb
----

// [silver]#After you have modified the *DeploymentConfig* object, you can verify the environment variables have been added by viewing the YAML for it:#

変更した後、*DeploymentConfig* オブジェクトの詳細をYAML形式で表示することで、設定した環境変数を確認することができます。

[source]
----
$ oc get dc nationalparks -o yaml
----

// [silver]#You should see the following section:#

次のセクションが表示されます。

[source]
----
- env:
  - name: MONGODB_USER
    value: mongodb
  - name: MONGODB_PASSWORD
    value: mongodb
  - name: MONGODB_DATABASE
    value: mongodb
  - name: MONGODB_SERVER_HOST
    value: mongodb
----

// [silver]#You can also just ask OpenShift to tell you about the environment variables on the DC:#

また、単に DC 上の環境変数について教えて OpenShift を求めることができます:

[source]
----
$ oc env dc/nationalparks --list
# deploymentconfigs nationalparks, container nationalparks
MONGODB_USER=mongodb
MONGODB_PASSWORD=mongodb
MONGODB_DATABASE=mongodb
MONGODB_SERVER_HOST=mongodb
----

#### Exercise: Exploring OpenShift Magic

// [silver]#As soon as we set the environment variables on the *DeploymentConfiguration*, some magic happened. OpenShift decided that this was a significant enough change to warrant updating the internal version number of the *DeploymentConfiguration*. You can verify this by looking at the output of `oc get dc`:#

環境変数を *DeploymentConfig* に設定すると、再デプロイが行われます。
`oc get dc` コマンドで確認します。

[source]
----
NAME            REVISION   DESIRED   CURRENT   TRIGGERED BY
mongodb         1          1         1         config,image(mongodb:3.2)
nationalparks   2          1         1         config,image(nationalparks:{{NATIONALPARKS_VERSION}})
parksmap        1          1         1         config,image(parksmap:{{PARKSMAP_VERSION}})
----

// [silver]#Something that increments the version of a *DeploymentConfiguration*, by default, causes a new deployment. You can verify this by looking at the output of `oc get rc`:#

デフォルトでは、新しいデプロイメントが作成されると、*DeploymentConfiguration* のバージョンがインクリメントされます。
`oc get rc` コマンドで確認してみましょう。

[source]
----
NAME              DESIRED   CURRENT   READY     AGE
mongodb-1         1         1         0         24m
nationalparks-1   0         0         0         3h
nationalparks-2   1         1         0         8m
parksmap-1        1         1         0         6h
----

// [silver]#We see that the desired and current number of instances for the "-1" deployment is 0. The desired and current number of instances for the "-2" deployment is 1.  This means that OpenShift has gracefully torn down our "old" application and stood up a "new" instance.#

"-1" のデプロイメントのインスタンスの DESIRED とCURRENT の数が 0 であることがわかります。"-2" のデプロイメントのインスタンスの DESIRED と CURRENT の数は 1 です。
これは、OpenShift が正常に私たちの"古い"アプリケーションを終了し、"新しい"インスタンス立ち上がったことを意味します。

#### Exercise: Data, Data, Everywhere

// [silver]#Now that we have a database deployed, we can again visit the `nationalparks` web service to query for data:#

データベースとの連携ができたので、再び `nationalparks` web サービスにアクセスしします。

[source]
----
http://nationalparks-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}/ws/data/all
----

// [silver]#And the result?#

結果は 0 件です。

[source]
----
[]
----

// [silver]#Where's the data? Think about the process you went through. You deployed the application and then deployed the database. Nothing actually loaded anything *INTO* the database, though.#

まだ、データベースにデータをロードしていないので、これが正しい状態です。

データはどこにありますか?あなたが通ったプロセスについて考えなさい。アプリケーションを展開し、データベースを配置します。何も実際には * データベースに何もロードされていない。

// [silver]#The application provides an endpoint to do just that:#

ここで、データのロードをします。

[source]
----
http://nationalparks-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}/ws/data/load
----

// [silver]#And the result?#

2740 件のデータが登録されたというメッセージが表示されます。

[source]
----
Items inserted in database: 2740
----

// [silver]#If you then go back to `/ws/data/all` you will see tons of JSON data now.  That's great. Our parks map should finally work!#

再び、 http://nationalparks-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}/ws/data/all  にアクセスすると JSON 形式で、2740 件のデータが返って来ます。


[NOTE]
====
// [silver]#There's some errors reported with browsers like firefox 54 that don't properly parse the resulting JSON. It's a browser problem, and the application is working properly.#

結果の json を正しく解析しない firefox 54 のようなブラウザで報告されたいくつかのエラーがあります。それはブラウザの問題、およびアプリケーションが正常に動作している。
====

[source]
----
http://parksmap-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}
----

// [silver]#Hmm... There's just one thing. The main map **STILL** isn't displaying the parks.  That's because the front end parks map only tries to talk to services that have the right *Label*.#


`parksmap` アプリケーションにアクセスしても、まだ、公園の座標が表示されていません。まだ、`parksmap` アプリケーションのバックエンドサービスとして `nationalparks` アプリケーションが認識されていないからです。

[NOTE]
====
// [silver]#You are probably wondering how the database connection magically started working? When deploying applications to OpenShift, it is always best to use environment variables to define connections to dependent systems.  This allows for application portability across different environments.  The source file that performs the connection as well as creates the database schema can be viewed here:#

あなたは、おそらくデータベース接続が魔法のように動作し始めたか疑問に思っている?アプリケーションを OpenShift に配置する場合は、常に環境変数を使用して依存システムへの接続を定義することをお勧めします。これにより、さまざまな環境でアプリケーションの移植性を実現できます。データベーススキーマを作成するだけでなく、接続を実行するソースファイルは、次のように表示されます。

[source,role=copypaste]
----
{% if PARKSMAP_PY %}
http://{{GITLAB_URL_PREFIX}}.{{ROUTER_ADDRESS}}/{{GITLAB_USER}}/nationalparks-py/blob/{{NATIONALPARKS_VERSION}}/wsgi.py#L11-18
{% else %}
http://{{GITLAB_URL_PREFIX}}.{{ROUTER_ADDRESS}}/{{GITLAB_USER}}/nationalparks/blob/{{NATIONALPARKS_VERSION}}/src/main/java/com/openshift/evg/roadshow/parks/db/MongoDBConnection.java#L44-l48
{% endif %}
----

// [silver]#In short summary: By referring to environment variables to connect to services (like databases), it can be trivial to promote applications throughout different lifecycle environments on OpenShift without having to modify application code.#
// [silver]#You can learn more about environment variables in the https://{{DOCS_URL}}/latest/dev_guide/environment_variables.html[environment variables] section of the Developer Guide.#

要約すると、(データベースのような) サービスに接続するための環境変数を参照することで、アプリケーションコードを変更することなく、openshift 上のさまざまなライフサイクル環境全体でアプリケーションを促進することは簡単です。
環境変数の詳細については、「開発者ガイド」の https://{{DOCS_URL}}/latest/dev_guide/environment_variables.html[environment variables] セクションを参照してください。

今回のラボの範囲ではやりませんが、Configmap という形式でプロパティを設定する方法もあります。
====

#### Exercise: Working With Labels

// [silver]#We explored how a *Label* is just a key=value pair earlier when looking at *Services* and *Routes* and *Selectors*. In general, a *Label* is simply an arbitrary key=value pair. It could be anything.#

*Service* 、*Route* や *Selector* を確認した時に、key=value のペアが設定されていることを確認しました。
*Label* は、OpenShift上のオブジェクトに設定可能な key=value のペアです。

* `pizza=pepperoni`
* `wicked=googly`
* `openshift=awesome`

// [silver]#In the case of the parks map, the application is actually querying the OpenShift API and asking about the *Routes* and *Services* in the project. If any of them have a *Label* that is `type=parksmap-backend`, the application knows to interrogate the endpoints to look for map data.#

`parksmap` アプリケーションは、座標情報を提供するバックエンドサービスを見つけるために、OpenShift API を利用します。その時、`type=parksmap-backend` というラベルたついた Route を検索し、バックエンドサービスとして利用します。

{% if PARKSMAP_PY %}
// [silver]#You can see the code that does this link:https://github.com/openshift-roadshow/parksmap-web-py/blob/1.0.0/app.py#L97[here].#

あなたはこのリンクを行うコードを見ることができますlink:https://github.com/openshift-roadshow/parksmap-web-py/blob/1.0.0/app.py#L97[ここ]。
{% else %}

// [silver]#You can see the code that does this#
// [silver]#link:https://github.com/openshift-roadshow/parksmap-web/blob/{{PARKSMAP_VERSION}}/src/main/java/com/openshift/evg/roadshow/rest/RouteWatcher.java#L20[here].#

これを行うコードを見ることができます。

link:https://github.com/openshift-roadshow/parksmap-web/blob/{{PARKSMAP_VERSION}}/src/main/java/com/openshift/evg/roadshow/rest/RouteWatcher.java#L20[ここ].
{% endif %}


// [silver]#Fortunately, the command line provides a convenient way for us to manipulate labels. `describe` the `nationalparks` service:#


コマンドラインを使って、*Label* をつけることができます。まずは、`oc describe` コマンドを使って `nationalparks` の *Route* を確認します。

[source]
----
$ oc describe route nationalparks

Name:                   nationalparks
Namespace:              {{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}
Created:                2 hours ago
Labels:                 app=nationalparks
Requested Host:         nationalparks-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}
                        exposed on router router 2 hours ago
Path:                   <none>
TLS Termination:        <none>
Insecure Policy:        <none>
Endpoint Port:          8080-tcp


Service:                nationalparks
Weight:                 100 (100%)
Endpoints:              10.1.9.8:8080
----

// [silver]#You see that it only has one label: `app=nationalparks`. Now, use `oc label`:#

現在は、`app=nationalparks` というラベルのみが付いていますので、`oc label` コマンドを使って `type=parksmap-backend` というラベルを付与します。

[source]
----
$ oc label route nationalparks type=parksmap-backend
----

// [silver]#You will see something like:#

このようなものが表示されます。

[source]
----
route "nationalparks" labeled
----

// [silver]#If you check your browser now:#

再びブラウザで `parksmap` アプリケーションにアクセスします。

[source]
----
http://parksmap-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}/
----

image::parksmap-new-parks.png[MongoDB]

// [silver]#You'll notice that the parks suddenly are showing up. That's really cool!#

あなたは公園が突然表示されていることがわかります。COOOOOOL!
