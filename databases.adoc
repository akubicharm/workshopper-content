## Lab: Adding a Database

### Application Description
[silver]#In this lab, we're going to deploy a Mongo database that will be used to store the data for the `nationalparks` application. We will also connect the `nationalparks` service with the newly deployed Mongo database, so that the `nationalparks` service can load and query the database for the corresponding information.#

この演習では `nationalparks` アプリケーションのデータを格納するために使用されます Mongo データベースを配置するつもりです。`nationalparks` サービスがロードしてについては、対応するデータベースを照会できるように `nationalparks` サービス新しく展開した Mongo データベースと接続もします。

[silver]#Finally, we will mark the `nationalparks` application as a backend for the map visualization tool, so that it can be dynamically discovered by the `parksmap` component using the OpenShift discovery mechanism and the map will be displayed automatically.#

最後に、我々 は、OpenShift の検出メカニズムを使用して `parksmap` コンポーネントによって動的に発見できるし、地図が自動的に表示されますマップ可視化ツールのバックエンドとして `nationalparks` アプリケーションを迎えます。

image::roadshow-app-architecture-nationalparks-2.png[Application architecture,800,align="center"]

### Background: Storage

[silver]#Most useful applications are "stateful" or "dynamic" in some way, and this is usually achieved with a database or other data storage. In this next lab we are going to add MongoDB to our `nationalparks` application and then rewire it to talk to the database using environment variables.#

最も有用なアプリケーションは"ステートフル"または"動的"いくつかの方法で、これは通常データベースまたは他のデータ記憶域で達成です。`nationalparks` アプリケーションを MongoDB を追加し、配線環境変数を使用してデータベースに相談するつもりですこの次の演習では。

[silver]#We are going to use the MongoDB image that is included with OpenShift.#

我々 は OpenShift に含まれている MongoDB イメージを使用しています。

[silver]#By default, this will use *EmptyDir* for data storage, which means if the *Pod* disappears the data does as well. In a real application you would use OpenShift's persistent storage mechanism to attach real-world storage (NFS, Gluster, EBS, etc) to the *Pods* to give them a persistent place to store their data.#

デフォルトでは、これはデータストレージに *EmptyDir* を使用しますが、これは *Pod* がデータを消失するかどうかを意味します。実際のアプリケーションでは、OpenShift の永続ストレージメカニズムを使用して、実際のストレージ (NFS、Gluster、EBS など) を *Pods* に接続し、データを保存するための永続的な場所を提供します。

### Background: Environment Variables

[silver]#As you've seen so far, the web console makes it very easy to deploy things onto OpenShift. When we deploy the database, we pass in some environment variables.  These environment variables are used to set the username, password, and name of the database.  You can change the values of these environment variables to anything you would like.  The variables we are going to be setting are as follows:#

あなたがこれまで見てきたように web コンソール、OpenShift に物事を展開する非常に簡単になります。データベースに展開する場合我々 はいくつかの環境変数を渡します。
これらの環境変数を使用して、ユーザー名、パスワード、およびデータベースの名前を設定します。 あなたが望む何かにこれらの環境変数の値を変更できます。 設定している変数は次のとおりです。

- MONGODB_USER
- MONGODB_PASSWORD
- MONGODB_DATABASE
- MONGODB_ADMIN_PASSWORD

[silver]#The database image is built in a way that it will automatically configure itself using the supplied information (assuming there is no data already present in the persistent storage!). The image will ensure that:#

- A database exists with the specified name
- A user exists with the specified name
- The user can access the specified database with the specified password

データベースのイメージは、自動的に (永続的なストレージに存在するデータがないと仮定!) 指定された情報を使用して自分自身を設定するという方法で構築されます。イメージを確認します。

- 指定した名前のデータベースが存在します
- 指定した名前のユーザーが存在する
- 指定されたパスワードで指定されたデータベースにアクセスできます

[silver]#In the web console in your `{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}` project, again click the *"Add to Project"* button. Click the *Data Stores* category.#

Web コンソールの `{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}` プロジェクトで、もう一度クリックして、*Add to Project* ボタン。クリックして、*Data Stores* カテゴリ。

image::mongodb-datastores.png[Data Stores]

[silver]#Type `mongodb` in the search box, and then scroll down to find the *MongoDB (Ephemeral)* template, and click it.  You will notice that there are several MongoDB templates available, some of which come with application servers pre-configured.  We just need a database, though, so the ephemeral Mongo template is what you should choose.#

検索ボックスに `mongodb` と入力し、下にスクロールして *MongoDB (Ephemeral)* テンプレートを見つけてクリックします。 使用可能な MongoDB テンプレートがいくつかあり、そのうちのいくつかがアプリケーションサーバーにあらかじめ構成されていることがわかります。 私たちは、しかし、データベースを必要とするので MongoDB(Ephemeral) テンプレートを選択する必要があります。

image::ocp-mongodb-template.png[MongoDB]

[silver]#When we performed the application build, there was no template. Rather, we selected the builder image directly and OpenShift presented only the standard build workflow.  Now we are using a template - a preconfigured set of resources that includes parameters that can be customized. In our case, the parameters we are concerned with are the environment variables discussed -- user, password, database, and admin password.#

我々 は、アプリケーションのビルドを実行するとき、テンプレートはありませんでした。むしろ、我々は直接ビルダー イメージを選択、OpenShift が標準のビルド ワークフローのみを提示します。
今我々 はテンプレートを使用しているリソースのセットがあらかじめパラメーターを含むカスタマイズことができます。私たちのケースで我々 はかかわっているパラメーターは、議論 - 環境変数ユーザー、パスワード、データベース、および管理者パスワードです。

image::ocp-mongo-template-deploy.png[MongoDB]

[silver]#You can see that some of the fields say *"generated if empty"*. This is a feature of *Templates* in OpenShift that will be covered in the next lab. For now, be sure to use the following values in their respective fields:#

あなたは、フィールドの一部が *"generated if empty"* と言うことがわかります。これは、次のラボでカバーされる OpenShift の *Templates* の機能です。ここでは、それぞれのフィールドに次の値を使用してください。


|===
| パラメータ名|環境変数名|値
|MongoDB Connection Username|`MONGODB_USER`|`mongodb`
|MongoDB Connection Password| `MONGODB_PASSWORD`|`mongodb`
|MongoDB Database Name| `MONGODB_DATABASE`|`mongodb`
|MongoDB Admin Password| `MONGODB_ADMIN_PASSWORD`|`mongodb`
|===

[silver]#You can leave the rest of the values as their defaults, and then click *"Create"*. Then click *Continue to overview*. The MongoDB instance should quickly be deployed.#

残りは既定値のままにしてをクリックして *"Create"*。クリックして *Continue to overview*。Mongo インスタンスは、迅速に展開する必要があります。

image::mongo-group-db-1.png[Service Groups]


[silver]#You can group services in OpenShift Console in order to display related services together in one panel. Click on the chain icon on the right-top corner of the `nationalparks` service, choose `mongodb` from the drop-down list in the *Group Service to nationalparks* dialog and click on *OK*. The `nationalparks` and `mongodb` services are groups and displayed together.#


OpenShift Console のサービスをグループ化して、関連するサービスを1つのパネルにまとめて表示することができます。`nationalparks` サービスの右上隅にあるチェーンアイコンをクリックし、 *Group Service to nationalparks* ダイアログのドロップダウンリストから `mongodb` を選択し、 *OK* をクリックします。 `nationalparks` および `mongodb` サービスはグループであり、一緒に表示されます。

image::mongo-group-db-2.png[Service Groups]


#### Exercise: Wiring the Application and the Database

[silver]#When we initially created the `nationalparks` application, we provided no environment variables. The application is looking for a database, but can't find one, and it fails gracefully (you don't see an error).#

最初に `nationalparks` アプリケーションを作成したとき、我々は環境変数を提供しませんでした。アプリケーションはデータベースを探していますが、1つを見つけることができず、正常に失敗します (エラーが表示されません)。

[silver]#We need to configure the `nationalparks` *Pod*(s) to have the right values in the right environment variables so that the application knows how and where to find MongoDB.#

我々 は `nationalparks` *Pod*(s)を設定する必要があります。アプリケーションは、方法や場所を知っているように、適切な環境変数に適切な値を持っている MongoDB を見つけよう。

[silver]#If you think way back to the beginning of the labs, you will recall that a *DeploymentConfiguration* tells OpenShift how to deploy something. This includes things like what environment variables to configure. So, to set up the right environment variables, we simply need to modify the *DeploymentConfiguration* (DC).  This can easily be done from either the web interface or via the command line.#


ラボの最初を振り返ると、*DeploymentConfiguration* は何かを展開する方法を OpenShift に指示することを思い出すでしょう。これには、構成する環境変数のようなものが含まれます。したがって、適切な環境変数を設定するには、単に *DeploymentConfiguration* (DC) を変更する必要があります。 これは、簡単に web インターフェイスまたはコマンドラインを介してから行うことができます。

[silver]#The command line takes a little less time, so let's use that option. First, find the name of the DC:#

コマンドラインは少し時間がかかります、そのオプションを使うことにしましょう。まず、DC の名前を見つけます。

[source]
----
$ oc get dc
----

[silver]#Then, use the `oc env` command to set environment variables directly on the DC:#

その後、DC に直接環境変数を設定する `oc env` コマンドを使用します。

[source]
----
$ oc env dc nationalparks -e MONGODB_USER=mongodb -e MONGODB_PASSWORD=mongodb -e MONGODB_DATABASE=mongodb -e MONGODB_SERVER_HOST=mongodb
----

[silver]#After you have modified the *DeploymentConfig* object, you can verify the environment variables have been added by viewing the YAML for it:#

変更した後、*DeploymentConfig* オブジェクト、変数はそれの YAML の表示によって追加されている環境を確認できます。

[source]
----
$ oc get dc nationalparks -o yaml
----

[silver]#You should see the following section:#

次のセクションが表示されます。

[source]
----
- env:
  - name: MONGODB_USER
    value: mongodb
  - name: MONGODB_PASSWORD
    value: mongodb
  - name: MONGODB_DATABASE
    value: mongodb
  - name: MONGODB_SERVER_HOST
    value: mongodb
----

[silver]#You can also just ask OpenShift to tell you about the environment variables on the DC:#

また、単に DC 上の環境変数について教えて OpenShift を求めることができます:

[source]
----
$ oc env dc/nationalparks --list
# deploymentconfigs nationalparks, container nationalparks
MONGODB_USER=mongodb
MONGODB_PASSWORD=mongodb
MONGODB_DATABASE=mongodb
MONGODB_SERVER_HOST=mongodb
----

#### Exercise: Exploring OpenShift Magic

[silver]#As soon as we set the environment variables on the *DeploymentConfiguration*, some magic happened. OpenShift decided that this was a significant enough change to warrant updating the internal version number of the *DeploymentConfiguration*. You can verify this by looking at the output of `oc get dc`:#

我々 はの環境変数を設定するとすぐに、*DeploymentConfiguration* いくつかの魔法が起こった。決定したの内部バージョン番号の更新を保証する十分に大きな変化の OpenShift、*DeploymentConfiguration*。`oc get dc` の出力を見ることによってこれを確認できます。

[source]
----
NAME            REVISION   DESIRED   CURRENT   TRIGGERED BY
mongodb         1          1         1         config,image(mongodb:3.2)
nationalparks   2          1         1         config,image(nationalparks:{{NATIONALPARKS_VERSION}})
parksmap        1          1         1         config,image(parksmap:{{PARKSMAP_VERSION}})
----

[silver]#Something that increments the version of a *DeploymentConfiguration*, by default, causes a new deployment. You can verify this by looking at the output of `oc get rc`:#

何かのバージョンをインクリメントする、*DeploymentConfiguration* 既定では、によって新しい展開。`oc get rc` の出力を見ることによってこれを確認できます。

[source]
----
NAME              DESIRED   CURRENT   READY     AGE
mongodb-1         1         1         0         24m
nationalparks-1   0         0         0         3h
nationalparks-2   1         1         0         8m
parksmap-1        1         1         0         6h
----

[silver]#We see that the desired and current number of instances for the "-1" deployment is 0. The desired and current number of instances for the "-2" deployment is 1.  This means that OpenShift has gracefully torn down our "old" application and stood up a "new" instance.#

"-1"展開のインスタンスの目的と現在の数が 0 であることがわかります。"-2"展開のインスタンスの目的と現在の数は 1 です。
これは、OpenShift が正常に私たちの"古い"アプリケーションを引き裂かれた、"新しい"インスタンス立ち上がったことを意味します。

#### Exercise: Data, Data, Everywhere

[silver]#Now that we have a database deployed, we can again visit the `nationalparks` web service to query for data:#

配備されているデータベースがあるので、我々 は再びデータのクエリに `nationalparks` web サービスを訪れることができます。

[source]
----
http://nationalparks-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}/ws/data/all
----

[silver]#And the result?#

そして、その結果?

[source]
----
[]
----

[silver]#Where's the data? Think about the process you went through. You deployed the application and then deployed the database. Nothing actually loaded anything *INTO* the database, though.#

データはどこにありますか?あなたが通ったプロセスについて考えなさい。アプリケーションを展開し、データベースを配置します。何も実際には * データベースに何もロードされていない。

[silver]#The application provides an endpoint to do just that:#

アプリケーションを提供することで、エンドポイント。

[source]
----
http://nationalparks-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}/ws/data/load
----

[silver]#And the result?#

そして、その結果?

[source]
----
Items inserted in database: 2740
----

[silver]#If you then go back to `/ws/data/all` you will see tons of JSON data now.  That's great. Our parks map should finally work!#

あなたが戻って '/ws/data/all ' に行く場合は、現在の json データのトンが表示されます。 素晴らしい。私たちの公園のマップは、最終的に動作するはず!

[NOTE]
====
[silver]#There's some errors reported with browsers like firefox 54 that don't properly parse the resulting JSON. It's a browser problem, and the application is working properly.#

結果の json を正しく解析しない firefox 54 のようなブラウザで報告されたいくつかのエラーがあります。それはブラウザの問題、およびアプリケーションが正常に動作している。
====

[source]
----
http://parksmap-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}
----

[silver]#Hmm... There's just one thing. The main map **STILL** isn't displaying the parks.  That's because the front end parks map only tries to talk to services that have the right *Label*.#

んん。。。1つだけです。メインマップは **まだ** 公園を表示していません。
それは、フロントエンドの公園のマップは、正しい *Label* を持っているサービスに話をしようとするためです。

[NOTE]
====
[silver]#You are probably wondering how the database connection magically started working? When deploying applications to OpenShift, it is always best to use environment variables to define connections to dependent systems.  This allows for application portability across different environments.  The source file that performs the connection as well as creates the database schema can be viewed here:#

あなたは、おそらくデータベース接続が魔法のように動作し始めたか疑問に思っている?アプリケーションを OpenShift に配置する場合は、常に環境変数を使用して依存システムへの接続を定義することをお勧めします。これにより、さまざまな環境でアプリケーションの移植性を実現できます。データベーススキーマを作成するだけでなく、接続を実行するソースファイルは、次のように表示されます。

[source,role=copypaste]
----
{% if PARKSMAP_PY %}
http://{{GITLAB_URL_PREFIX}}.{{ROUTER_ADDRESS}}/{{GITLAB_USER}}/nationalparks-py/blob/{{NATIONALPARKS_VERSION}}/wsgi.py#L11-18
{% else %}
http://{{GITLAB_URL_PREFIX}}.{{ROUTER_ADDRESS}}/{{GITLAB_USER}}/nationalparks/blob/{{NATIONALPARKS_VERSION}}/src/main/java/com/openshift/evg/roadshow/parks/db/MongoDBConnection.java#L44-l48
{% endif %}
----

[silver]#In short summary: By referring to environment variables to connect to services (like databases), it can be trivial to promote applications throughout different lifecycle environments on OpenShift without having to modify application code.#
[silver]#You can learn more about environment variables in the https://{{DOCS_URL}}/latest/dev_guide/environment_variables.html[environment variables] section of the Developer Guide.#

要約すると、(データベースのような) サービスに接続するための環境変数を参照することで、アプリケーションコードを変更することなく、openshift 上のさまざまなライフサイクル環境全体でアプリケーションを促進することは簡単です。
環境変数の詳細については、「開発者ガイド」の https://{{DOCS_URL}}/latest/dev_guide/environment_variables.html[environment variables] セクションを参照してください。
====

#### Exercise: Working With Labels

[silver]#We explored how a *Label* is just a key=value pair earlier when looking at *Services* and *Routes* and *Selectors*. In general, a *Label* is simply an arbitrary key=value pair. It could be anything.#

我々は、*Label* は、*Services* と *Route* と *Selectors* を見ているときに、以前の key=value のペアだけである方法を検討した。一般的に、*Label* は単に任意の key=value のペアです。それは何でもよい。

* `pizza=pepperoni`
* `wicked=googly`
* `openshift=awesome`

[silver]#In the case of the parks map, the application is actually querying the OpenShift API and asking about the *Routes* and *Services* in the project. If any of them have a *Label* that is `type=parksmap-backend`, the application knows to interrogate the endpoints to look for map data.#

公園マップの場合、アプリケーションは実際に openshift api を照会し、プロジェクトの *Routes* および *Services* について尋ねることになります。それらのいずれかが `type = parksmap-backend` である *Label* を持っている場合、アプリケーションは、マップデータを探すためにエンドポイントを尋問することを知っています。

{% if PARKSMAP_PY %}
[silver]#You can see the code that does this link:https://github.com/openshift-roadshow/parksmap-web-py/blob/1.0.0/app.py#L97[here].#

あなたはこのリンクを行うコードを見ることができますlink:https://github.com/openshift-roadshow/parksmap-web-py/blob/1.0.0/app.py#L97[ここ]。
{% else %}

[silver]#You can see the code that does this#
[silver]#link:https://github.com/openshift-roadshow/parksmap-web/blob/{{PARKSMAP_VERSION}}/src/main/java/com/openshift/evg/roadshow/rest/RouteWatcher.java#L20[here].#

これを行うコードを見ることができます。

link:https://github.com/openshift-roadshow/parksmap-web/blob/{{PARKSMAP_VERSION}}/src/main/java/com/openshift/evg/roadshow/rest/RouteWatcher.java#L20[ここ].
{% endif %}


[silver]#Fortunately, the command line provides a convenient way for us to manipulate labels. `describe` the `nationalparks` service:#

幸いなことに、コマンド ・ ラインは、私たちのラベルを操作するための便利な方法を提供します。`describe` `nationalparks` サービスを説明します。

[source]
----
$ oc describe route nationalparks

Name:                   nationalparks
Namespace:              {{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}
Created:                2 hours ago
Labels:                 app=nationalparks
Requested Host:         nationalparks-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}
                        exposed on router router 2 hours ago
Path:                   <none>
TLS Termination:        <none>
Insecure Policy:        <none>
Endpoint Port:          8080-tcp


Service:                nationalparks
Weight:                 100 (100%)
Endpoints:              10.1.9.8:8080
----

[silver]#You see that it only has one label: `app=nationalparks`. Now, use `oc label`:#

あなたはのみ 1 つのラベルがあるを参照してください: `app=nationalparks`。今、`oc label` を使用します。

[source]
----
$ oc label route nationalparks type=parksmap-backend
----

[silver]#You will see something like:#

このようなものが表示されます。

[source]
----
route "nationalparks" labeled
----

[silver]#If you check your browser now:#

今お使いのブラウザーを確認すると: 場合

[source]
----
http://parksmap-{{EXPLORE_PROJECT_NAME}}{{USER_SUFFIX}}.{{ROUTER_ADDRESS}}/
----

image::parksmap-new-parks.png[MongoDB]

[silver]#You'll notice that the parks suddenly are showing up. That's really cool!#

あなたは公園が突然表示されていることがわかります。それは本当にクールだ!
